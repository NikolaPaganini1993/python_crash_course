# Как работает функция input()
# Функция input() приостанавливает выполнение программы и ожидает, пока пользователь введет некоторый текст.
# Получив ввод, Python сохраняет его в переменной, чтобы вам было удобнее работать с ним.
# Например, следующая программа предлагает пользователю ввести текст, а затем выводит сообщение для пользователя:
# message = input("Tell me something, and I will repeat it back to you: ")
# print(message)

# Использование int() для получения числового ввода
# При использовании функции input() Python интерпретирует все данные, введенные пользователем, как строку.
# В следующем сеансе интерпретатора программа запрашивает у пользователя возраст:
# age = input("How old are you? ")
# print(age)

# Как использовать функцию int() в реальной программе? Допустим, программа
# проверяет рост пользователя и определяет, достаточен ли он для катания на аттракционе:
# height = input("How tall are you, in inches? ")
# height = int(height)
# if height >= 48:
#     print("\nYou're tall enough to ride!")
# else:
#     print("\nYou'll be able to ride when you're a little older.")

# Оператор вычисления остатка
# При работе с числовыми данными может пригодиться оператор вычисления остатка (%),
# который делит одно число на другое и возвращает остаток:
# Оператор % не сообщает частное от целочисленного деления; он возвращает только остаток.
# Когда одно число нацело делится на другое, остаток равен 0, и оператор % возвращает 0.
# Например, этот факт может использоваться для проверки четности или нечетности числа:
# number = input("Enter a number, and I'll tell you if it's even or odd: ")
# number = int(number)
# if number % 2 == 0:
#     print(f"\nThe number {number} is even.")
# else:
#     print(f"\nThe number {number} is odd.")

# Циклы while
# Цикл for получает коллекцию элементов и выполняет блок кода по одному разу для каждого элемента в коллекции.
# В отличие от него, цикл while продолжает выполняться, пока остается истинным некоторое условие.
# Цикл while в действии
# Цикл while может использоваться для перебора числовой последовательности.
# Например, следующий цикл считает от 1 до 5:
# current_number = 1
# while current_number <= 5:
#     print(current_number)
#     current_number += 1

# Пользователь решает прервать работу программы
# Программа может выполняться, пока пользователь не захочет остановить ее,
# — для этого большая часть кода заключается в цикл while.
# В программе определяется признак завершения, и программа работает, пока пользователь не введет нужное значение:
# prompt = "\nTell me something, and I will repeat it back to you:"
# prompt += "\nEnter 'quit' to end the program. "
# message = ""
# while message != 'quit':
#     message = input(prompt)
#     print(message)

# Флаги
# В предыдущем примере программа выполняла некоторые операции, пока заданное условие оставалось истинным.
# А если вы пишете более сложную программу, выполнение которой может прерываться по нескольким разным условиям?
# Например, компьютерная игра может завершаться по разным причинам: у игрока кончились все «жизни»;
# прошло отведенное время; все города, которые он должен был защищать, были уничтожены и т. д.
# Игра должна завершаться при выполнении любого из этих условий.
# Попытки проверять все возможные условия в одной команде while быстро усложняются и становятся слишком громоздкими.
# Если программа должна выполняться только при истинности нескольких условий, определите одну переменную-флаг.
# Эта переменная сообщает, должна ли программа выполняться далее.
# Программу можно написать так, чтобы она продолжала выполнение, если флаг находится в состоянии True, и завершалась,
# если любое из нескольких событий перевело флаг в состояние False.
# В результате в команде while достаточно проверить всего одно условие: находится ли флаг в состоянии True.
# Все остальные проверки (которые должны определить, произошло ли событие, переводящее флаг в состояние False)
# удобно организуются в остальном коде.
# Добавим флаг в программу parrot.py из предыдущего раздела.
# Этот флаг, который мы назовем active (хотя переменная может называться как угодно), управляет тем,
# должно ли продолжаться выполнение программы:
# prompt = "\nTell me something, and I will repeat it back to you:"
# prompt += "\nEnter 'quit' to end the program. "
# active = True
# while active:
#     message = input(prompt)
#     if message == 'quit':
#         active = False
#     else:
#         print(message)

# Команда break и выход из цикла
# Чтобы немедленно прервать цикл while без выполнения оставшегося кода в цикле независимо от состояния условия,
# используйте команду break.
# Команда break управляет ходом выполнения программы; она позволит вам управлять тем,
# какая часть кода выполняется, а какая нет.
# Рассмотрим пример — программу, которая спрашивает у пользователя, в каких городах он бывал.
# Чтобы прервать цикл while, программа выполняет команду break,
# как только пользователь введет значение 'quit':
# prompt = "\nPlease enter the name of a city you have visited:"
# prompt += "\n(Enter 'quit' when you are finished.) "
# while True:
#     city = input(prompt)
#     if city == 'quit':
#         break
#     else:
#         print(f"I'd love to go to {city.title()}!")

# Команда continue и продолжение цикла
# Вместо того чтобы полностью прерывать цикл без выполнения оставшейся части кода,
# вы можете воспользоваться командой continue для возвращения к началу цикла и проверке условия.
# Например, возьмем цикл, который считает от 1 до 10, но выводит только нечетные числа в этом диапазоне:
# current_number = 0
# while current_number < 10:
#     current_number += 1
#     if current_number % 2 == 0:
#         continue
#     print(current_number)

# Предотвращение зацикливания
# У каждого цикла while должна быть предусмотрена возможность завершения, чтобы цикл не выполнялся бесконечно.
# Например, следующий цикл считает от 1 до 5:
# x = 1
# while x <= 5:
#     print(x)
#     x += 1
# Если ваша программа зациклилась, нажмите Ctrl+C или просто закройте терминальное окно с выводом программы.
# Чтобы избежать зацикливания, тщательно проверьте каждый цикл while и убедитесь в том,
# что цикл прерывается именно тогда, когда предполагается.
# Если программа должна завершаться при вводе некоторого значения, запустите программу и введите это значение.
# Если программа не завершилась, проанализируйте обработку значения, которое должно приводить к выходу из цикла.
# Проверьте, что хотя бы одна часть программы может привести к тому,
# что условие цикла станет равно False или будет выполнена команда break.

# Перемещение элементов между списками
# Возьмем список недавно зарегистрированных, но еще не проверенных пользователей сайта.
# Как переместить пользователей после проверки в отдельный список проверенных пользователей?
# Одно из возможных решений: используем цикл while для извлечения пользователей из списка непроверенных,
# проверяем их и включаем в отдельный список проверенных пользователей.
# Код может выглядеть так:
# unconfirmed_users = ['alice', 'brian', 'candace']     # Начинаем с двух списков: пользователей для проверки
# confirmed_users = []                                  # и пустого списка для хранения проверенных пользователей.
# while unconfirmed_users:                              # Проверяем каждого пользователя, пока остаются непроверенные
#     current_user = unconfirmed_users.pop()            # пользователи. Каждый пользователь, прошедший проверку,
#     print(f"Verifying user: {current_user.title()}")  # перемещается в список проверенных.
#     confirmed_users.append(current_user)
# print("\nThe following users have been confirmed:")   # Вывод всех проверенных пользователей.
# for confirmed_user in confirmed_users:
#     print(confirmed_user.title())

# Удаление всех вхождений конкретного значения из списка
# В главе 3 функция remove() использовалась для удаления конкретного значения из списка.
# Функция remove() работала, потому что интересующее нас значение встречалось в списке только один раз.
# Но что, если вы захотите удалить все вхождения значения из списка?
# Допустим, имеется список pets, в котором значение 'cat' встречается многократно.
# Чтобы удалить все экземпляры этого значения, можно выполнять цикл while до тех пор,
# пока в списке не останется ни одного экземпляра 'cat':
# pets = ['dog', 'cat', 'dog', 'goldfish', 'cat', 'rabbit', 'cat']
# print(pets)
# while 'cat' in pets:
#     pets.remove('cat')
# print(pets)

# Заполнение словаря данными, введенными пользователем
# При каждом проходе цикла while ваша программа может запрашивать любое необходимое количество данных.
# Напишем программу, которая при каждом проходе цикла запрашивает имя участника и его ответ.
# Собранные данные будут сохраняться в словаре, потому что каждый ответ должен быть связан с конкретным пользователем:
# responses = {}
# polling_active = True                                                          # Установка флага продолжения опроса.
# while polling_active:
#     name = input("\nWhat is your name? ")                                      # Запрос имени и ответа пользователя.
#     response = input("Which mountain would you like to climb someday? ")
#     responses[name] = response                                                 # Ответ сохраняется в словаре:
#     repeat = input("Would you like to let another person respond? (yes/ no) ") # Проверка продолжения опроса.
#     if repeat == 'no':
#         polling_active = False                                                 # Опрос завершен, вывести результаты.
# print("\n--- Poll Results ---")
# for name, response in responses.items():
#     print(f"{name.title()} would like to climb {response.title()}.")