# Эта глава посвящена функциям — именованным блокам кода, предназначенным для решения одной конкретной задачи.
# Чтобы выполнить задачу, определенную в виде функции, вы вызываете функцию, отвечающую за эту задачу.
# Если задача должна многократно выполняться в программе, вам не придется заново вводить весь необходимый код;
# просто вызовите функцию, предназначенную для решения задачи, и этот вызов прикажет Python выполнить код,
# содержащийся внутри функции. Как вы вскоре убедитесь, использование функций упрощает чтение, написание,
# тестирование кода и исправление ошибок.
# Определение функции
# Вот простая функция с именем greet_user (), которая выводит приветствие:
# def greet_user():
#     print("Hello!")
# greet_user()

# Передача информации функции
# С небольшими изменениями функция greet_user() сможет не только сказать «Привет!» пользователю,
# но и поприветствовать его по имени.
# Для этого следует включить имя username в круглых скобках в определении функции def greet_user().
# С добавлением username функция примет любое значение, которое будет заключено в скобки при вызове.
# Теперь функция ожидает, что при каждом вызове будет передаваться имя пользователя.
# При вызове greet_user() укажите имя (например, 'jesse') в круглых скобках:
# def greet_user(username):
#     print(f"Hello, {username.title()}!")
# greet_user('jesse')
# Команда greet_user('jesse') вызывает функцию greet_user()
# и передает ей информацию, необходимую для выполнения команды print.

# Аргументы и параметры
# Функция greet_user() определена так, что для работы она должна получить значение переменной username.
# После того как функция будет вызвана и получит необходимую информацию (имя пользователя),
# она выведет правильное приветствие.
# Переменная username в определении greet_user() — параметр, то есть условные данные,
# необходимые функции для выполнения ее работы.
# ПАРАМЕТР ЭТО ОБЩЕЕ. НАПРИМЕР: def greet_user(USERNAME)
# АРГУМЕНТ ЭТО ЧАСТНОЕ. НАПРИМЕР: greet_user('NIKOLA')
# Значение 'jesse' в greet_user('jesse') — аргумент, то есть конкретная информация, переданная при вызове функции.
# Вызывая функцию, вы заключаете значение, с которым функция должна работать, в круглые скобки.
# В данном случае аргумент 'jesse' был передан функции greet_user(),
# а его значение было сохранено в переменной username.

# Передача аргументов
# Определение функции может иметь несколько параметров, и может оказаться,
# что при вызове функции должны передаваться несколько аргументов.
# Существуют несколько способов передачи аргументов функциям.
# Позиционные аргументы перечисляются в порядке, точно соответствующем порядку записи параметров;
# именованные аргументы состоят из имени переменной и значения; наконец, существуют списки и словари значений.
# Рассмотрим все эти способы.

# Позиционные аргументы
# При вызове функции каждому аргументу должен быть поставлен в соответствие параметр в определении функции.
# Проще всего сделать это на основании порядка перечисления аргументов.
# Значения, связываемые с аргументами подобным образом, называются позиционными аргументами.
# Чтобы понять, как работает эта схема, рассмотрим функцию для вывода информации о домашних животных.
# Функция сообщает тип животного и его имя:
# def describe_pet(animal_type, pet_name):
#     print(f"\nI have a {animal_type}.")
#     print(f"My {animal_type}'s name is {pet_name.title()}.")
# describe_pet('hamster', 'harry')

# Многократные вызовы функций
# Функция может вызываться в программе столько раз, сколько потребуется.
# Для вывода информации о другом животном достаточно одного вызова describe_pet():
# def describe_pet(animal_type, pet_name):
#     print(f"\nI have a {animal_type}.")
#     print(f"My {animal_type}'s name is {pet_name.title()}.")
# describe_pet('hamster', 'harry')
# describe_pet('dog', 'willie')

# Именованные аргументы
# Именованный аргумент представляет собой пару «имя-значение», передаваемую функции.
# Имя и значение связываются с аргументом напрямую, так что при передаче аргумента путаница с порядком исключается.
# Именованные аргументы избавляют от хлопот с порядком аргументов при вызове функции,
# а также проясняют роль каждого значения в вызове функции.
# Перепишем программу pets.py с использованием именованных аргументов при вызове describe_pet():
# def describe_pet(animal_type, pet_name):
#     print(f"\nI have a {animal_type}.")
#     print(f"My {animal_type}'s name is {pet_name.title()}.")
# describe_pet(animal_type='hamster', pet_name='harry')

# Значения по умолчанию
# Для каждого параметра вашей функции можно определить значение по умолчанию.
# Если при вызове функции передается аргумент, соответствующий данному параметру,
# Python использует значение аргумента, а если нет — использует значение по умолчанию.
# Таким образом, если для параметра определено значение по умолчанию,
# вы можете опустить соответствующий аргумент, который обычно включается в вызов функции.
# Значения по умолчанию упрощают вызовы функций и проясняют типичные способы использования функций.
# Например, если вы заметили, что большинство вызовов describe_pet() используется для описания собак,
# задайте animal_type значение по умолчанию 'dog'.
# Теперь в любом вызове describe_pet() для собаки эту информацию можно опустить:
# def describe_pet(pet_name, animal_type='dog'):
#     print(f"\nI have a {animal_type}.")
#     print(f"My {animal_type}'s name is {pet_name.title()}.")
# describe_pet(pet_name='willie')
# describe_pet(pet_name='kuga', animal_type='cat')

# Возвращаемое значение
# Функция не обязана выводить результаты своей работы напрямую.
# Вместо этого она может обработать данные, а затем вернуть значение или набор сообщений.
# Значение, возвращаемое функцией, называется возвращаемым значением.
# Команда return передает значение из функции в точку программы, в которой эта функция была вызвана.
# Возвращаемые значения помогают переместить большую часть рутинной работы в вашей программе в функции,
# чтобы упростить основной код программы.

# Возвращение простого значения
# Рассмотрим функцию, которая получает имя и фамилию и возвращает аккуратно отформатированное полное имя:
# def get_formatted_name(first_name, last_name):
#     full_name = f"{first_name} {last_name}"
#     return full_name.title()
# musician = get_formatted_name('jimi', 'hendrix')
# print(musician)

# Необязательные аргументы
# Иногда бывает удобно сделать аргумент необязательным, чтобы разработчик, использующий функцию,
# мог передать дополнительную информацию только в том случае, если он этого захочет.
# Чтобы сделать аргумент необязательным, можно воспользоваться значением по умолчанию.
# Чтобы средний аргумент был необязательным, можно присвоить аргументу middle_name пустое значение по умолчанию;
# этот аргумент игнорируется, если пользователь не передал для него значение.
# Чтобы функция get_formatted_name() работала без второго имени, следует назначить
# для параметра middle_name пустую строку значением по умолчанию и переместить его в конец списка параметров:
# def get_formatted_name(first_name, last_name, middle_name=''):
#     if middle_name:
#         full_name = f"{first_name} {middle_name} {last_name}"
#     else:
#         full_name = f"{first_name} {last_name}"
#     return full_name.title()
# musician = get_formatted_name('john', 'lee', 'hooker')
# print(musician)
# musician = get_formatted_name('vitya', 'ak47')
# print(musician)
# musician = get_formatted_name(first_name='vitya', last_name='ak47')
# print(musician)

# Возвращение словаря
# Функция может вернуть любое значение, которое вам потребуется,
# в том числе и более сложную структуру данных (например, список или словарь).
# Так, следующая функция получает части имени и возвращает словарь, представляющий человека:
# def build_person(first_name, last_name):
#     person = {'first': first_name, 'last': last_name}
#     return person
# musician = build_person('jimi', 'hendrix')
# print(musician)

# Функция получает простую текстовую информацию и помещает ее в более удобную структуру данных,
# которая позволяет работать с информацией (помимо простого вывода).
# Строки 'jimi' и 'hendrix' теперь помечены как имя и фамилия.
# Функцию можно легко расширить так, чтобы она принимала дополнительные значения — второе имя, возраст,
# профессию или любую другую информацию о человеке, которую вы хотите сохранить.
# Например, следующее изменение позволяет также сохранить возраст человека:
# def build_person(first_name, last_name, age=None):
#     person = {'first': first_name, 'last': last_name}
#     if age:
#         person['age'] = age
#     return person
# musician = build_person('jimi', 'hendrix', age=27)
# print(musician)
# musician = build_person('maxim', 'ak47')
# print(musician)

# Использование функции в цикле while
# Функции могут использоваться со всеми структурами Python, уже известными вам.
# Например, используем функцию get_formatted_name() в цикле while,
# чтобы поприветствовать пользователей более официально.
# Первая версия программы, приветствующей пользователей по имени и фамилии, может выглядеть так:
# def get_formatted_name(first_name, last_name):
#     full_name = f"{first_name} {last_name}"
#     return full_name.title()
# # Бесконечный цикл!
# while True:
#     print("\nPlease tell me your name:")
#     f_name = input("First name: ")
#     l_name = input("Last name: ")
#     formatted_name = get_formatted_name(f_name, l_name)
# print(f"\nHello, {formatted_name}!")

# Но у этого цикла while есть один недостаток: в нем не определено условие завершения.
# Где следует разместить условие завершения при запросе серии данных?
# Пользователю нужно предоставить возможность выйти из цикла как можно раньше,
# так что в приглашении должен содержаться способ завершения.
# Команда break позволяет немедленно прервать цикл при запросе любого из компонентов:
# def get_formatted_name(first_name, last_name):
#     full_name = f"{first_name} {last_name}"
#     return full_name.title()
# while True:
#     print("\nPlease tell me your name:")
#     print("(enter 'q' at any time to quit)")
#     f_name = input("First name: ")
#     if f_name == 'q':
#         break
#     l_name = input("Last name: ")
#     if l_name == 'q':
#         break
#     formatted_name = get_formatted_name(f_name, l_name)
#     print(f"\nHello, {formatted_name}!")

# Передача списка
# Часто при вызове функции удобно передать список — имен, чисел или более сложных объектов (например, словарей).
# При передаче списка функция получает прямой доступ ко всему его содержимому.
# Мы воспользуемся функциями для того, чтобы сделать работу со списком более эффективной.
# Допустим, вы хотите вывести приветствие для каждого пользователя из списка.
# В следующем примере список имен передается функции greet_users(),
# которая выводит приветствие для каждого пользователя по отдельности:
# def greet_users(names):
#     for name in names:
#         msg = f"Hello, {name.title()}!"
#         print(msg)
# usernames = ['hannah', 'ty', 'margot']
# greet_users(usernames)

# Изменение списка в функции
# Если вы передаете список функции, код функции сможет изменить список.
# Все изменения, внесенные в список в теле функции, закрепляются,
# что позволяет эффективно работать со списком даже при больших объемах данных.
# Допустим, компания печатает на 3D-принтере модели, предоставленные пользователем.
# Проекты хранятся в списке, а после печати перемещаются в отдельный список.
# В следующем примере приведена реализация, не использующая функции:
# unprinted_designs = ['phone case', 'robot pendant', 'dodecahedron']
# completed_models = []
# while unprinted_designs:
#     current_design = unprinted_designs.pop()
#     print(f"Printing model: {current_design}")
#     completed_models.append(current_design)
# print("\nThe following models have been printed:")
# for completed_model in completed_models:
#     print(completed_model)
# В начале программы создается список моделей и пустой список completed_models,
# в который каждая модель перемещается после печати.
# Пока в unprinted_designs остаются модели, цикл while имитирует печать каждой модели: модель удаляется из конца списка,
# сохраняется в current_design, а пользователь получает сообщение о том, что текущая модель была напечатана.
# Затем модель перемещается в список напечатанных.

# Мы можем изменить структуру этого кода: для этого следует написать две функции,
# каждая из которых решает одну конкретную задачу.
# Большая часть кода останется неизменной; просто программа становится более эффективной.
# Первая функция занимается печатью, а вторая выводит сводку напечатанных моделей:
# unprinted_designs = ['phone case', 'robot pendant', 'dodecahedron']
# completed_models = []
# def print_models(unprinted_designs, completed_models):
#     while unprinted_designs:
#         current_design = unprinted_designs.pop()
#         print(f"Printing model: {current_design}")
#         completed_models.append(current_design)
# def show_completed_models(completed_models):
#     print("\nThe following models have been printed:")
#     for completed_model in completed_models:
#         print(completed_model)
# print_models(unprinted_designs, completed_models)
# show_completed_models(completed_models)

# Запрет изменения списка в функции
# Иногда требуется предотвратить изменение списка в функции.
# Допустим, у вас имеется список моделей для печати и вы пишете функцию для перемещения их в список готовых моделей,
# как в предыдущем примере. Возможно, даже после печати всех моделей исходный список нужно оставить для отчетности.
# Но поскольку все имена моделей были перенесены из списка unprinted_designs,
# остался только пустой список; исходная версия списка потеряна.
# Проблему можно решить передачей функции копии списка вместо оригинала.
# В этом случае все изменения, вносимые функцией в список,
# будут распространяться только на копию, а оригинал списка остается неизменным.
# Чтобы передать функции копию списка, можно поступить так:
# имя_функции(имя_списка[:])
# Синтаксис сегмента [:] создает копию списка для передачи функции.
# Если удаление элементов из списка unprinted_designs в print_models.py нежелательно,
# функцию print_models() можно вызвать так:
# print_models(unprinted_designs[:], completed_models)
# Функция print_models() может выполнить свою работу,
# потому что она все равно получает имена всех ненапечатанных моделей.
# Но на этот раз она использует не сам список unprinted_designs, а его копию.
# Список completed_models заполняется именами напечатанных моделей,
# как и в предыдущем случае, но исходный список функцией не изменяется.
# Несмотря на то, что передача копии позволяет сохранить содержимое списка,
# обычно функциям следует передавать исходный список (если у вас нет веских причин для передачи копии).
# Работа с существующим списком более эффективна, потому что программе не приходится тратить время
# и память на создание отдельной копии (лишние затраты особенно заметны при работе с большими списками).

# Передача произвольного набора аргументов
# В некоторых ситуациях вы не знаете заранее, сколько аргументов должно быть передано функции.
# К счастью, Python позволяет функции получить произвольное количество аргументов из вызывающей команды.
# Для примера рассмотрим функцию для создания пиццы.
# Функция должна получить набор топпингов к пицце, но вы не знаете заранее, сколько топпингов закажет клиент.
# Функция в следующем примере получает один параметр *toppings,
# но этот параметр объединяет все аргументы, заданные в командной строке:
# Звездочка в имени параметра *toppings приказывает Python создать пустой кортеж с именем toppings
# и упаковать в него все полученные значения.
# def make_pizza(*toppings):
#     print(toppings)
# make_pizza('pepperoni')
# make_pizza('mushrooms', 'green peppers', 'extra cheese')

# Теперь команду print можно заменить циклом, который перебирает список топпингов и выводит описание заказанной пиццы:
# def make_pizza(*toppings):
#     print("\nMaking a pizza with the following toppings:")
#     for topping in toppings:
#         print(f"- {topping}")
# make_pizza('pepperoni')
# make_pizza('mushrooms', 'green peppers', 'extra cheese')

# Позиционные аргументы с произвольными наборами аргументов
# Если вы хотите, чтобы функция могла вызываться с разными количествами аргументов,
# параметр для получения произвольного количества аргументов должен стоять на последнем месте в определении функции.
# Python сначала подбирает соответствия для позиционных и именованных аргументов,
# а потом объединяет все остальные аргументы в последнем параметре.
# Например, если функция должна получать размер пиццы, этот параметр должен стоять в списке до параметра *toppings:
# def make_pizza(size, *toppings):
#     print(f"\nMaking a {size}-inch pizza with the following toppings:")
#     for topping in toppings:
#         print(f"- {topping}")
# make_pizza(16, 'pepperoni')
# make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')
# В определении функции Python сохраняет первое полученное значение в параметре size.
# Все остальные значения, следующие за ним, сохраняются в кортеже toppings.
# В вызовах функций на первом месте располагается аргумент для параметра size,
# а за ним следуют сколько угодно дополнений.

# Использование произвольного набора именованных аргументов
# Иногда программа должна получать произвольное количество аргументов,
# но вы не знаете заранее, какая информация будет передаваться функции.
# В таких случаях можно написать функцию, получающую столько пар «ключ-значение», сколько указано в команде вызова.
# Один из возможных примеров — построение пользовательских профилей:
# вы знаете, что вы получите информацию о пользователе, но не знаете заранее, какую именно.
# Функция build_profile() в следующем примере всегда получает имя и фамилию,
# но также может получать произвольное количество именованных аргументов:
# def build_profile(first, last, **user_info):
#     user_info['first_name'] = first
#     user_info['last_name'] = last
#     return user_info
# user_profile = build_profile('albert', 'einstein',
# location='princeton',
# field='physics')
# print(user_profile)
# Определение build_profile() ожидает получить имя и фамилию пользователя,
# а также позволяет передать любое количество пар «имя-значение».
# Две звездочки перед параметром **user_info заставляют Python создать пустой словарь с именем user_info
# и упаковать в него все полученные пары «имя-значение».
# Внутри функции вы можете обращаться к парам «имя-значение» из user_info точно так же, как в любом словаре.


# Хранение функций в модулях
# Одно из преимуществ функций заключается в том, что они отделяют блоки кода от основной программы.
# Если для функций были выбраны содержательные имена, ваша программа будет намного проще читаться.
# Можно пойти еще дальше и сохранить функции в отдельном файле, называемом модулем,
# а затем импортировать модуль в свою программу.
# Команда import сообщает Python, что код модуля должен быть доступен в текущем выполняемом программном файле.
# Хранение функций в отдельных файлах позволяет скрыть второстепенные детали кода
# и сосредоточиться на логике более высокого уровня.
# Кроме того, функции можно использовать во множестве разных программ.
# Функции, хранящиеся в отдельных файлах,
# можно передать другим программистам без распространения полного кода программы.
# А умение импортировать функции позволит вам использовать библиотеки функций, написанные другими программистами.
# Существует несколько способов импортирования модулей; все они кратко рассматриваются ниже.


# Импортирование всего модуля
# Чтобы заняться импортированием функций, сначала необходимо создать модуль.
# Модуль представляет собой файл с расширением .py, содержащий код, который вы хотите импортировать в свою программу.
# Давайте создадим модуль с функцией make_pizza().
# Для этого из файла pizza.py следует удалить все, кроме функции make_pizza():
# pizza.py
def make_pizza(size, *toppings):
    print(f"\nMaking a {size}-inch pizza with the following toppings:")
    for topping in toppings:
        print(f"- {topping}")
# Теперь создайте отдельный файл с именем making_pizzas.py в одном каталоге с pizza. py.
# Файл импортирует только что созданный модуль, а затем дважды вызывает make_pizza():
# making_pizzas.py
# import pizza
# ❶ pizza.make_pizza(16, 'pepperoni')
# pizza.make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')
# В процессе обработки этого файла строка import pizza говорит Python открыть файл pizza.py
# и скопировать все функции из него в программу.
# Вы не видите, как происходит копирование,
# потому что Python копирует код незаметно для пользователя во время выполнения программы.
# Вам необходимо знать одно: что любая функция, определенная в pizza.py, будет доступна в making_pizzas.py.


# Импортирование конкретных функций
# Также возможно импортировать конкретную функцию из модуля. Общий синтаксис выглядит так:
# from имя_модуля import имя_функции
# Вы можете импортировать любое количество функций из модуля, разделив их имена запятыми:
# from имя_модуля import функция_0, функция_1, функция_2
# Если ограничиться импортированием только той функции, которую вы намереваетесь использовать,
# пример making_pizzas.py будет выглядеть так:
from chapter8 import make_pizza
make_pizza(16, 'pepperoni')
make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')
# При таком синтаксисе использовать точечную запись при вызове функции не обязательно.
# Так как функция make_pizza() явно импортируется в команде import, при использовании ее можно вызывать прямо по имени.


# Назначение псевдонима для функции
# Если имя импортируемой функции может конфликтовать
# с именем существующей функции или функция имеет слишком длинное имя,
# его можно заменить коротким уникальным псевдонимом (alias) — альтернативным именем для функции.
# Псевдоним назначается функции при импортировании.
# В следующем примере функции make_pizza() назначается псевдоним mp(),
# для чего при импортировании используется конструкция make_pizza as mp.
# Ключевое слово as переименовывает функцию, используя указанный псевдоним:
from chapter8 import make_pizza as mp
mp(16, 'pepperoni')
mp(12, 'mushrooms', 'green peppers', 'extra cheese')
# Команда import в этом примере назначает функции make_pizza() псевдоним mp() для этой программы.
# Каждый раз, когда потребуется вызвать make_pizza(),
# достаточно включить вызов mp() — Python выполнит код make_pizza() без конфликтов с другой функцией make_pizza(),
# которую вы могли включить в этот файл программы.


# Назначение псевдонима для модуля
# Псевдоним также можно назначить для всего модуля.
# Назначение короткого имени для модуля — скажем, p для pizza — позволит вам быстрее вызывать функции модуля.
# Вызов p.make_pizza() получается более компактным, чем pizza.make_pizza():
import chapter8 as p
p.make_pizza(16, 'pepperoni')
p.make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')
# Модулю pizza в команде import назначается псевдоним p, но все функции модуля сохраняют свои исходные имена.
# Вызов функций в записи p.make_pizza() не только компактнее pizza.make_pizza();
# он также отвлекает внимание от имени модуля и помогает сосредоточиться на содержательных именах функций.
# Эти имена функций, четко показывающие, что делает каждая функция,
# важнее для удобочитаемости вашего кода, чем использование полного имени модуля.


# Импортирование всех функций модуля
# Также можно приказать Python импортировать каждую функцию в модуле; для этого используется оператор *:
from chapter8 import *
make_pizza(16, 'pepperoni')
make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')
# Звездочка в команде import приказывает Python скопировать каждую функцию из модуля chapter8 в файл программы.
# После импортирования всех функций вы сможете вызывать каждую функцию по имени без точечной записи.
# Тем не менее лучше не использовать этот способ с большими модулями, написанными другими разработчиками;
# если модуль содержит функцию, имя которой совпадает с существующим именем из вашего проекта,
# возможны неожиданные результаты.
# Python обнаруживает несколько функций или переменных с одинаковыми именами,
# и вместо импортирования всех функций по отдельности происходит замена этих функций.
# В таких ситуациях лучше всего импортировать только нужную функцию или функции
# или же импортировать весь модуль с последующим применением точечной записи.
# При этом создается чистый код, легко читаемый и понятный.
# Я включил этот раздел только для того, чтобы вы понимали команды import вроде следующей,
# когда вы встретите их в чужом коде:
# from имя_модуля import *